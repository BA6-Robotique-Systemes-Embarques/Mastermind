/*
 * run.c
 *
 *  Created on: 20 April 2021
 *      Author: Cyril Monette
 */

#include "ch.h"
#include "hal.h"
#include <math.h>
#include <usbcfg.h>

#include <main.h>
#include <motors.h>
#include <process_image.h>
#include <run.h>
#include <detectionIR.h>
#include <game_logic.h>
#include <leds.h>

#define SPEED_BASE 						400 // Motors' nominal speed
#define POSITION_MOTEUR_CHAMP_VISION 	770 // Distance seen by the camera converted into motor position
#define POSITION_MOTEUR_ROTATION180 		660

#define RIGHT 	0
#define LEFT 	1

#define STARTUP_BACKUP_DIST 		-1210
#define STARTUP_BACKUP_SAFETY 	10
#define STARTUP_BACKUP_SETUP		-400
#define SCANNING_CLOSEUP_DIST	100

// ETAT_FOLLOW = following the black line, ETAT_GAMEHINT = (red spot) goes into break after scanning 3 cards
// ETAT_SCAN = (blue spot) scan a card, ETAT_PAUSE = wait for hand signal, ETAT_STOP = used for reset :
static char etat = ETAT_FOLLOW;

static bool soloMode = false; // Solo mode is a game mode where the code2break is randomly generated by the e-puck2
static bool ReadytoScan = false;
static bool objectInFront = false; // Updated by detectionIR.c to confirm that a card is in front of the e-puck2
static bool cardScanned = false; // Informs run.c that a card has been processed
static bool ignoreSCAN = false;

static uint8_t currentCard;


//----------------BASIC MOTOR CONTROL----------------

static void move_dist(int motorPos){ // Positive position = go forward, negative = go backwards
	left_motor_set_pos(0);
	right_motor_set_pos(0);
	if (motorPos>0){
		right_motor_set_speed(SPEED_BASE);
		left_motor_set_speed(SPEED_BASE);
		while(left_motor_get_pos()<motorPos) {__asm__ volatile ("nop");}
	}
	else if (motorPos<=0){
		right_motor_set_speed(-SPEED_BASE);
		left_motor_set_speed(-SPEED_BASE);
		while(left_motor_get_pos()>motorPos) {__asm__ volatile ("nop");}
	}
	right_motor_set_speed(0);
	left_motor_set_speed(0);
}

static void turn_dist(int motorPos){ // Positive position = clockwise, negative = counterclockwise
	left_motor_set_pos(0);
	right_motor_set_pos(0);
	if (motorPos>0){
		right_motor_set_speed(-SPEED_BASE);
		left_motor_set_speed(SPEED_BASE);
		while(left_motor_get_pos()<motorPos) {__asm__ volatile ("nop");}
	}
	else if (motorPos<=0){
		right_motor_set_speed(SPEED_BASE);
		left_motor_set_speed(-SPEED_BASE);
		while(left_motor_get_pos()>motorPos) {__asm__ volatile ("nop");}
	}
	right_motor_set_speed(0);
	left_motor_set_speed(0);
}

static void turnAround_move(void){
	turn_dist(POSITION_MOTEUR_ROTATION180);
}

void stopMotors(void){
	right_motor_set_speed(0);
	left_motor_set_speed(0);
	left_motor_set_pos(0);
	right_motor_set_pos(0);
}

//-------------COMPLEX MOTOR FUNCTIONS----------------

void starting_move(void){
	// Get out of the beginning slot:
	move_dist(STARTUP_BACKUP_SAFETY);
	move_dist(STARTUP_BACKUP_DIST);

	// Turn towards the line to follow:
	turn_dist(-POSITION_MOTEUR_ROTATION180/2);
	move_dist(STARTUP_BACKUP_SETUP);
}

static void scan_move(bool orientation){ // Large function to handle the entire scanning process
	// Open loop towards the spot, turns and gets close to the card:
	move_dist(POSITION_MOTEUR_CHAMP_VISION);
	set_body_led(OFF);
	if (orientation==LEFT) turn_dist(-1*POSITION_MOTEUR_ROTATION180/2);
	else if (orientation==RIGHT) turn_dist(POSITION_MOTEUR_ROTATION180/2);
	move_dist(SCANNING_CLOSEUP_DIST);

	ReadytoScan = true; // Signals to other threads that they can start scanning the front of the robot
	while(!cardScanned){
		chThdSleepMilliseconds(10); // Waits for processing of card colors
	}

	// Resets booleans used to communicate to other threads, turning them off
	ReadytoScan = false;
	objectInFront = false;
	cardScanned=false;
	setAttemptPin(currentCard);// Communicates what card was just scanned

	// Open loop back onto the black line
	move_dist(-SCANNING_CLOSEUP_DIST);
	if (orientation==LEFT) turn_dist(POSITION_MOTEUR_ROTATION180/2);
	else if (orientation==RIGHT) turn_dist(-1*POSITION_MOTEUR_ROTATION180/2);
}

static void break_move(void){ // Called when a red spot is spotted
	move_dist(POSITION_MOTEUR_CHAMP_VISION);
	turnAround_move();
}

//---------------------THREAD---------------------


static THD_WORKING_AREA(waRun, 256);
static THD_FUNCTION(Run, arg) {

    chRegSetThreadName(__FUNCTION__);
    (void)arg;

    systime_t time;
    int16_t speedR = 0, speedL = 0;

    // PID :
    float erreur=0, erreur_precedente=0, erreurtot=0;
    float Kp=2, Ki=0.04, Kd=0;

    while(1){
        time = chVTGetSystemTime();

        if(etat==ETAT_FOLLOW){
        	erreur=getPos(); // Error between -320 and 320
        	erreurtot+=erreur;

        	if(erreurtot>700.)       erreurtot= 700.;	// Anti Wind-up
        	else if(erreurtot<-700.) erreurtot=-700.;	// Anti Wind-up

        	speedR = SPEED_BASE-(Kp*erreur+Ki*erreurtot+Kd*(erreur-erreur_precedente));
        	speedL = SPEED_BASE+(Kp*erreur+Ki*erreurtot+Kd*(erreur-erreur_precedente));

        	right_motor_set_speed(speedR);
        	left_motor_set_speed(speedL);

        	erreur_precedente=erreur;
        }

        else if(etat==ETAT_SCAN){
        	if(getTurnCounter()==0 && soloMode){// In solo mode there is no need to scan the code2break as it is set up randomly
        		move_dist(POSITION_MOTEUR_CHAMP_VISION/2);
        		setAttemptPin(0);
        		if(getTurnCounter()==1 && soloMode) setRandomGamecode();
        	}
        	else if((getTurnCounter()==0 || getTurnCounter()==1)) // Cards are to the right during first 6 scans
        		scan_move(RIGHT);
        	else if (getTurnCounter()>1){ // Cards are to the left when the robot scans from the red spot
        		uint8_t TC_beforeScan = getTurnCounter();
        		scan_move(LEFT);
        		// Moves back to pause spot once the 3 cards have been scanned
        		if (TC_beforeScan!=getTurnCounter()){
        			ignoreSCAN = true;
        			turnAround_move();
        		}
        	}

        	// Resets PID :
        	erreur_precedente=0;
        	erreurtot=0;

        	etat=ETAT_FOLLOW;
        }

        else if(etat==ETAT_GAMEHINT){
        	break_move(); // Moves to the red spot and turns around

        	ignoreSCAN = false; // Turns back on the ability to detect scanning (blue) spots

        	// Resets PID :
        	erreur_precedente=0;
        	erreurtot=0;

        	etat=ETAT_PAUSE;
        }
        // 100 Hz :
        chThdSleepUntilWindowed(time, time + MS2ST(10));
    }
}

void run_thd_start(void){
	chThdCreateStatic(waRun, sizeof(waRun), NORMALPRIO, Run, NULL);
}

//-------------------------GETTERS AND SETTERS----------------------------
char getEtat(void){
	return etat;
}

void setEtat(char c){
	switch(c){
		case ETAT_PAUSE : etat = ETAT_PAUSE; break;
		case ETAT_FOLLOW : etat = ETAT_FOLLOW; break;
		case ETAT_SCAN : etat = ETAT_SCAN; break;
		case ETAT_GAMEHINT : etat = ETAT_GAMEHINT; break;
		case ETAT_STOP : etat = ETAT_STOP; break;
	}
}

bool getObjectInFront(void){
	return objectInFront;
}

void setObjectInFront(bool object){
	objectInFront=object;
}

bool getReadytoScan(void){
	return ReadytoScan;
}

void setCurrentCard(uint8_t card){
	if(card != COLOR_WRONG){
		currentCard = card;
		cardScanned=true;
	}
}

bool getIgnoreScan(void){
	return ignoreSCAN;
}

bool getSoloMode(void){
	return soloMode;
}

void setSoloMode(bool mode){
	soloMode=mode;
}
